#!/bin/bash
#+
# This script runs Blender in batch mode on the specified .blend file,
# and extracts the geometry of a specified mesh object in Python form,
# such that it can be passed to the from_py_data API call to recreate
# the mesh geometry.
#-

opterror()
  {
    echo "$0: $1" 1>&2
    exit 3
  } # opterror

blender=blender
do_obj=
do_mesh=
for ((;;)); do
    if [ "${1:0:2}" != "--" ]; then
        break
    fi
    if [ "$1" == "--" ]; then
        shift
        break
    fi
    opt="${1:2:${#1}}"
    shift
    val="${opt#*=}"
    opt="${opt%%=*}"
    if [ "$opt" = "blender" ]; then
        blender="$val"
    elif [ "$opt" = "mesh" ]; then
        do_mesh="$val"
    elif [ "$opt" = "object" ]; then
        do_obj="$val"
    else
        opterror "bad option $opt"
    fi
done
if [ -z "$(type -p "$blender")" ]; then
    opterror "no such executable “$blender”"
fi
if [ $# != 1 ]; then
    opterror $'Usage:\n\t'"$0 "$'<blendfile>'
fi
blendfile="$1"
export RENDER_blendfile="$blendfile"
export RENDER_do_obj="$do_obj"
export RENDER_do_mesh="$do_mesh"

exec "$blender" -noaudio 5>&1 1>/dev/null -b -P <(cat <<'EOD'
import sys
import os
import getopt
import bpy

try :
    os.wait() # gobble zombie child of shell which was previously in this process slot
except ChildProcessError :
    # can happen intermittently?
    pass
#end try

out = os.fdopen(5, "w")
  # use a different fd from stdout, only way it seems to avoid
  # output being polluted by Blender’s messages

#+
# Mainline
#-

blendfile = os.getenv("RENDER_blendfile")
do_obj = os.getenv("RENDER_do_obj", "")
do_mesh = os.getenv("RENDER_do_mesh", "")
nr_digits = 7

bpy.ops.wm.open_mainfile(filepath = blendfile)
if do_obj != "" and do_mesh != "" :
    raise getopt.GetoptError("specify at most one of --object or --mesh")
#end if
if do_obj == "" and do_mesh == "" :
    the_obj = bpy.context.scene.objects.active
    if the_obj == None :
        raise getopt.GetoptError("no object specified, and no active object")
    #end if
elif do_obj != "" :
    the_obj = bpy.data.objects.get(do_obj)
    if the_obj == None :
        raise getopt.GetoptError("no such object “%s”" % do_obj)
    #end if
else :
    the_obj = None
#end if
if the_obj != None :
    the_mesh = the_obj.data
    if type(the_mesh) != bpy.types.Mesh :
        raise getopt.GetoptError("object “%s” is not a mesh" % do_obj)
    #end if
elif do_mesh != "" :
    the_mesh = bpy.data.meshes.get(do_mesh)
    if the_mesh == None :
        raise getopt.GetoptError("no such mesh “%s”" % do_mesh)
    #end if
else :
    assert False
#end if

out.write \
  (
    "vertices = \\\n"
    "  [\n"
  )
verts_format = "(" + ", ".join(["%%.%dg" % nr_digits] * 3) + ")"
for v in the_mesh.vertices :
    out.write("    " + verts_format % tuple(v.co) + ",\n")
#end for
out.write \
  (
    "  ]\n"
    "\n"
    "faces = \\\n"
    "  [\n"
  )
for f in the_mesh.polygons :
    out.write \
      (
        "    [" + ", ".join("%d" % i for i in f.vertices) + "],\n"
      )
#end for
out.write \
  (
    "  ]\n"
  )
if the_obj != None and len(the_obj.vertex_groups) != 0 :
    group_indices = dict \
      (
        (the_obj.vertex_groups[i].name, i)
        for i in range(len(the_obj.vertex_groups))
      )
    groups = {}
    for v in the_mesh.vertices :
        for vg in v.groups :
            if vg.group in groups :
                group_entry = groups[vg.group]
            else :
                group_entry = {}
                groups[vg.group] = group_entry
            #end if
            group_entry[v.index] = vg.weight
        #end for
    #end for
    out.write \
      (
        "vertex_groups = \\\n"
        "  {\n"
      )
    for group_name in sorted(group_indices.keys()) :
        group_index = group_indices[group_name]
        group_vertices = groups.get(group_index, {})
        out.write("    %s :\n" % repr(group_name))
        out.write("      {\n")
        for v in sorted(group_vertices.keys()) :
            out.write("        %%d : %%.%dg,\n" % nr_digits % (v, group_vertices[v]))
        #end for
        out.write("      },\n")
    #end for
    out.write \
      (
        "  }\n"
      )
#end if
EOD
)
